// https://codingcompetitions.withgoogle.com/codejam/round/0000000000433551/0000000000433a0f

/*
// The following object is generated by:

const fastestToPower = {};
function precalculate() {
  fastestToPower[1] = 10;
  let count = 10;
  for (let i = 2; i < 15; i++) {
    // The fastest way to get from 10...0 to the next power of ten is to:
    // - Count up to 100...09...999
    // - Reverse the number
    // - Count up from 999...90...01 to 99...9
    // - Count over to the next power of 10.
    count += 10 ** Math.ceil(i / 2) - 1 + 1 + 10 ** Math.ceil((i - 1) / 2) - 1;
    fastestToPower[i] = count;
  }
  console.log(fastestToPower);
}
precalculate();
*/

// fastestToPower[i] is the minimum number of turns to get to 10**i.
const fastestToPower = {
  1: 10,
  2: 29,
  3: 138,
  4: 337,
  5: 1436,
  6: 3435,
  7: 14434,
  8: 34433,
  9: 144432,
  10: 344431,
  11: 1444430,
  12: 3444429,
  13: 14444428,
  14: 34444427,
};

/*
// Dynamic Programming Solution that works for small-ish N:

const MAX = 100000;

const arr = [0];
for (let i = 1; i < MAX; i++) {
  arr.push(Infinity);
}

for (let i = 0; i < MAX; i++) {
  const reversed = parseInt(`${i}`.split("").reverse().join(""), 10);
  if (reversed > i) {
    arr[reversed] = Math.min(arr[reversed], 1 + arr[i]);
  }
  arr[i + 1] = Math.min(arr[i + 1], 1 + arr[i]);
}

const solve = i => arr[i];

// // Check against itself. This DP approach works if and only if we can't get a
// // more optimal answer on a second pass.
// for (let i = 0; i < MAX; i++) {
//   const reversed = parseInt(`${i}`.split("").reverse().join(""), 10);
//   if (reversed < MAX) {
//     assert(arr[reversed] <= 1 + arr[i], `${i}, ${arr[reversed]}, ${arr[i]}`);
//   }
//   assert(arr[i + 1] <= 1 + arr[i], `${i}, end`);
// }
// console.log("verified");


*/

function solve(target) {
  if (target <= 10) return target;

  const digits = `${target}`.length;
  let count = fastestToPower[digits - 1];
  if (target == 10 ** (digits - 1)) return count;

  const lastDigitIsZero = `${target}`.slice(-1) == "0";
  // We cannot get to a number ending in zero by reversing, so if the last digit
  // is zero, aim for one less than the target number.
  if (lastDigitIsZero) target -= 1;

  const firstHalfLength = Math.floor(digits / 2);
  const secondHalfLength = Math.ceil(digits / 2);

  const firstHalfReversed = parseInt(
    `${target}`.slice(0, firstHalfLength).split("").reverse().join(""),
    10
  );
  const secondHalf = parseInt(`${target}`.slice(-secondHalfLength));

  if (firstHalfReversed !== 1) {
    // Count out the reversed first half, then reverse.
    // The first half then matches the target, and the second half is 0...01.
    count += firstHalfReversed + 1;
  } else {
    // No point reversing.
    // Just add one, so that the second half is 0...01.
    count += 1;
  }

  // Add up the remaining half.
  count += secondHalf - 1;

  // If we adjusted the target down, go back up to the original target.
  if (lastDigitIsZero) count += 1;

  return count;
}

// Input/Output for Code Jam
const readline = require("readline");

async function processLineByLine() {
  const iterator = readline
    .createInterface({
      input: process.stdin,
      crlfDelay: Infinity,
    })
    [Symbol.asyncIterator]();

  const testCases = parseInt((await iterator.next()).value, 10);
  for (let i = 1; i < testCases + 1; i++) {
    const soln = solve(parseInt((await iterator.next()).value, 10));
    console.log(`Case #${i}: ${soln}`);
  }
}

processLineByLine();
